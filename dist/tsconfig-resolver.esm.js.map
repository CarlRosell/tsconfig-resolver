{"version":3,"file":"tsconfig-resolver.esm.js","sources":["../src/index.ts"],"sourcesContent":["import { existsSync, lstatSync, readFileSync, statSync } from 'fs';\nimport JSON5 from 'json5';\nimport { dirname, join, resolve } from 'path';\nimport StripBom from 'strip-bom';\nimport { TsConfigJson, Except } from 'type-fest';\nimport path from 'path';\n\nconst DEFAULT_FILENAME = 'tsconfig.json';\n\ninterface IsNodeModuleRequireOptions {\n  /**\n   * Whether to simulate windows.\n   *\n   * @default undefined\n   */\n  windows?: boolean;\n}\n\ninterface ParseFilePath {\n  /**\n   * True when the file path provided is an absolute path.\n   */\n  isAbsolute: boolean;\n\n  /**\n   * True when the file path potentially refers to a node module package.\n   */\n  isPackage: boolean;\n}\n\n/**\n * Extends the default node file parser and determines whether the path provided\n * should be resolved from the node modules or directly from the provided path.\n */\nconst parseFilePath = (\n  file: string,\n  { windows }: IsNodeModuleRequireOptions = {},\n): path.ParsedPath & ParseFilePath => {\n  const isWindows = windows ?? process.platform === 'win32';\n  const parser = isWindows ? path.win32.parse : path.parse;\n  const parsedPath = parser(file);\n\n  return {\n    ...parsedPath,\n    isAbsolute: Boolean(parsedPath.root),\n    isPackage: !file.startsWith('.') && !parsedPath.root,\n  };\n};\n\n/**\n * The reason that the tsconfig exist flag is false.\n */\nexport const TsConfigErrorReason = {\n  /**\n   * The `tsconfig` file could not be found.\n   */\n  NotFound: 'not-found',\n\n  /**\n   * The file was found but the configuration was invalid.\n   */\n  InvalidConfig: 'invalid-config',\n} as const;\n\ninterface TsConfigFailure {\n  /**\n   * Whether or not the configuration could be loaded.\n   *\n   * - `false` when no tsconfig could be found.\n   */\n  exists: false;\n\n  /**\n   * The configuration object.\n   *\n   * - `undefined` when the tsconfig resolver failed and no configuration was\n   *   found.\n   */\n  config?: undefined;\n}\n\nexport interface TsConfigFailureNotFound extends TsConfigFailure {\n  /**\n   * The reason for failure.\n   *\n   * - `TsConfigErrorReason.NotFound` when the config failure is because the\n   *   filename has not been found.\n   */\n  reason: typeof TsConfigErrorReason.NotFound;\n\n  /**\n   * The absolute path to the `tsconfig.json` or given filename.\n   *\n   * - `undefined` when not found.\n   */\n  path?: undefined;\n}\n\nexport interface TsConfigFailureInvalidConfig extends TsConfigFailure {\n  /**\n   * - `TsConfigErrorReason.InvalidConfig` when the config failure is because of\n   *   an invalid config.\n   */\n  reason: typeof TsConfigErrorReason.InvalidConfig;\n\n  /**\n   * - `string` when config json is invalid.\n   */\n  path: string;\n}\n\nexport interface TsConfigResultSuccess {\n  /**\n   * - `true` when a valid tsconfig file has been found and successfully loaded.\n   */\n  exists: true;\n\n  /**\n   * - `string` when a valid tsconfig has been loaded.\n   */\n  path: string;\n\n  /**\n   * - `TsConfigJson` when the resolved tsconfig has been found and loaded.\n   */\n  config: TsConfigJson;\n\n  /**\n   * - `undefined` when no failure has occurred.\n   */\n  reason?: undefined;\n}\n\n/**\n * The result of loading the tsconfig. If the exists property is `true` then\n * there will be a path and config property available.\n */\nexport type TsConfigResult =\n  | TsConfigFailureNotFound\n  | TsConfigFailureInvalidConfig\n  | TsConfigResultSuccess;\n\nexport interface TsConfigLoaderParams {\n  getEnv: (key: string) => string | undefined;\n  cwd: string;\n  loadSync?(cwd: string, fileName?: string): TsConfigResult;\n}\n\nconst walkForTsConfig = (directory: string): string | undefined => {\n  const configPath = join(directory, './tsconfig.json');\n  if (existsSync(configPath)) {\n    return configPath;\n  }\n\n  const parentDirectory = join(directory, '../');\n\n  // If we reached the top\n  if (directory === parentDirectory) {\n    return undefined;\n  }\n\n  return walkForTsConfig(parentDirectory);\n};\n\n/**\n * Check that the passed string is a directory.\n */\nconst isDirectory = (directory: string) => {\n  try {\n    return lstatSync(directory).isDirectory();\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Check that the passed filePath is a valid file.\n */\nconst isFile = (filePath: string) => {\n  try {\n    return lstatSync(filePath).isFile();\n  } catch {\n    return false;\n  }\n};\n\nconst resolveConfigPath = (\n  cwd: string,\n  fileName: string = DEFAULT_FILENAME,\n): string | undefined => {\n  if (fileName !== DEFAULT_FILENAME) {\n    const resolvedFileName = resolve(cwd, fileName);\n    const absolutePath = isDirectory(resolvedFileName)\n      ? resolve(resolvedFileName, 'tsconfig.json')\n      : resolvedFileName;\n\n    return isFile(absolutePath) ? absolutePath : undefined;\n  }\n\n  if (statSync(cwd).isFile()) {\n    return resolve(cwd);\n  }\n\n  const configAbsolutePath = walkForTsConfig(cwd);\n  return configAbsolutePath ? resolve(configAbsolutePath) : undefined;\n};\n\n/**\n * Loads the `jsonString` and returns it as a TsConfigJson object.\n */\nconst parseTsConfigJson = (jsonString: string): TsConfigJson | undefined => {\n  try {\n    const json = JSON5.parse(jsonString);\n    return json && typeof json === 'object' ? json : undefined;\n  } catch {\n    return undefined;\n  }\n};\n\n/**\n * Loads a tsconfig file while also resolving the extends path.\n */\nconst loadTsConfig = (configFilePath: string): TsConfigJson | undefined => {\n  if (!existsSync(configFilePath)) return undefined;\n\n  const configString = readFileSync(configFilePath, 'utf8');\n  const jsonString = StripBom(configString);\n  const config = parseTsConfigJson(jsonString);\n  let extendedConfig = config?.extends;\n\n  if (!config || !extendedConfig) return config;\n\n  let base: TsConfigJson;\n\n  if (parseFilePath(extendedConfig).isPackage) {\n    const newConfigPath = require.resolve(extendedConfig);\n\n    if (isDirectory(newConfigPath)) {\n      extendedConfig = join(newConfigPath, 'tsconfig.json');\n    } else if (isFile(newConfigPath)) {\n      extendedConfig = newConfigPath;\n    } else if (isFile(`${newConfigPath}.json`)) {\n      extendedConfig = `${newConfigPath}.json`;\n    }\n\n    base = loadTsConfig(extendedConfig) ?? {};\n  } else {\n    if (!extendedConfig.endsWith('.json')) {\n      extendedConfig += '.json';\n    }\n\n    const currentDir = dirname(configFilePath);\n    base = loadTsConfig(join(currentDir, extendedConfig)) ?? {};\n  }\n\n  // baseUrl should be interpreted as relative to the base tsconfig, but we need\n  // to update it so it is relative to the original tsconfig being loaded\n  if (base?.compilerOptions?.baseUrl) {\n    const extendsDir = dirname(extendedConfig);\n    base.compilerOptions.baseUrl = join(\n      extendsDir,\n      base.compilerOptions.baseUrl,\n    );\n  }\n\n  return {\n    ...base,\n    ...config,\n    compilerOptions: {\n      ...base.compilerOptions,\n      ...config.compilerOptions,\n    },\n  };\n};\n\nexport interface TsConfigResolverOptions {\n  /**\n   * The absolute directory to start resolving from.\n   *\n   * @default `process.cwd()`\n   */\n  cwd?: string;\n\n  /**\n   * The fileName to use.\n   *\n   * @default 'tsconfig.json'\n   */\n  fileName?: string;\n\n  /**\n   * The caching strategy to use.\n   *\n   * @default 'never'\n   *\n   * @remarks\n   *\n   * Sometimes you'll want to run this module several times during runtime but\n   * it can be slow and expensive walk up the file tree for the tsconfig value\n   * every time.\n   *\n   * To help prevent unnecessary lookups there are custom caching strategies\n   * available. See {@link CacheStrategy}.\n   */\n  cacheStrategy?: CacheStrategyType;\n}\n\nexport const CacheStrategy = {\n  /**\n   * Caching never happens and the returned value is always recalculated.\n   */\n  Never: 'never',\n\n  /**\n   * The first time the `tsconfigResolver` method is run it will save a cached\n   * value (by `fileName`) which will be returned every time after that. This\n   * value will always be the same.\n   */\n  Always: 'always',\n\n  /**\n   * The cache will be used when the same directory (and fileName) is being\n   * searched.\n   */\n  Directory: 'directory',\n} as const;\n\n/**\n * The available cache strategies as a union of strings.\n */\nexport type CacheStrategyType = typeof CacheStrategy[keyof typeof CacheStrategy];\n\nconst cacheObject = {\n  [CacheStrategy.Always]: new Map<string, TsConfigResult>(),\n  [CacheStrategy.Directory]: new Map<string, TsConfigResult>(),\n};\n\n/**\n * Based on the options passed in, retrieve the value from the cache or return\n * undefined if the value still needs to be calculated.\n */\nconst getCache = ({\n  cacheStrategy,\n  cwd,\n  fileName,\n}: Required<TsConfigResolverOptions>): TsConfigResult | undefined => {\n  if (cacheStrategy === CacheStrategy.Always) {\n    return cacheObject[CacheStrategy.Always].get(fileName);\n  }\n\n  if (cacheStrategy === CacheStrategy.Directory) {\n    return cacheObject[CacheStrategy.Always].get(join(cwd, fileName));\n  }\n\n  return undefined;\n};\n\n/**\n * Updates the cache with the provided result.\n */\nconst updateCache = (\n  { cacheStrategy, cwd, fileName }: Required<TsConfigResolverOptions>,\n  result: TsConfigResult,\n): void => {\n  if (cacheStrategy === CacheStrategy.Always) {\n    cacheObject[CacheStrategy.Always].set(fileName, result);\n  } else if (cacheStrategy === CacheStrategy.Directory) {\n    cacheObject[CacheStrategy.Always].set(join(cwd, fileName), result);\n  }\n};\n\n/**\n * Get the nearest tsconfig by walking up the directory.\n */\nconst getTsConfigResult = ({\n  cwd,\n  fileName,\n}: Required<\n  Except<TsConfigResolverOptions, 'cacheStrategy'>\n>): TsConfigResult => {\n  const configPath = resolveConfigPath(cwd, fileName);\n\n  if (!configPath) {\n    return {\n      exists: false,\n      reason: TsConfigErrorReason.NotFound,\n    };\n  }\n\n  const config = loadTsConfig(configPath);\n\n  if (!config) {\n    return {\n      exists: false,\n      reason: TsConfigErrorReason.InvalidConfig,\n      path: configPath,\n    };\n  }\n\n  return {\n    exists: true,\n    path: configPath,\n    config,\n  };\n};\n\n/**\n * Resolve the `tsconfig` file synchronously. Walks up the file tree until it\n * finds a file that matches the fileName.\n *\n * @param options - `TsConfigResolverOptions`.\n *\n * @returns an object containing whether a configuration was found and is valid.\n *\n * @remarks\n *\n * If a none default caching strategy is provided the returned result might be\n * from the cache instead.\n */\nexport function tsconfigResolver({\n  cwd = process.cwd(),\n  cacheStrategy = CacheStrategy.Never,\n  fileName = DEFAULT_FILENAME,\n}: TsConfigResolverOptions = {}): TsConfigResult {\n  const cache = getCache({ cwd, cacheStrategy, fileName });\n\n  if (cache) {\n    return cache;\n  }\n\n  const result = getTsConfigResult({ cwd, fileName });\n  updateCache({ cwd, cacheStrategy, fileName }, result);\n\n  return result;\n}\n\n/**\n * Clears the cache.\n */\nexport const clearCache = () => {\n  for (const map of Object.values(cacheObject)) {\n    map.clear();\n  }\n};\n"],"names":["DEFAULT_FILENAME","parseFilePath","file","windows","isWindows","process","platform","parser","path","win32","parse","parsedPath","isAbsolute","Boolean","root","isPackage","startsWith","TsConfigErrorReason","NotFound","InvalidConfig","walkForTsConfig","directory","configPath","join","existsSync","parentDirectory","undefined","isDirectory","lstatSync","isFile","filePath","resolveConfigPath","cwd","fileName","resolvedFileName","resolve","absolutePath","statSync","configAbsolutePath","parseTsConfigJson","jsonString","json","JSON5","loadTsConfig","configFilePath","configString","readFileSync","StripBom","config","extendedConfig","base","newConfigPath","require","endsWith","currentDir","dirname","compilerOptions","baseUrl","extendsDir","CacheStrategy","Never","Always","Directory","cacheObject","Map","getCache","cacheStrategy","get","updateCache","result","set","getTsConfigResult","exists","reason","tsconfigResolver","cache","clearCache","Object","values","map","clear"],"mappings":"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"}