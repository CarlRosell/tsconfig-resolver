{"version":3,"file":"tsconfig-resolver.cjs.production.min.js","sources":["../src/index.ts"],"sourcesContent":["import { existsSync, lstatSync, readFileSync, statSync } from 'fs';\nimport JSON5 from 'json5';\nimport { dirname, join, resolve } from 'path';\nimport StripBom from 'strip-bom';\nimport { TsConfigJson, Except } from 'type-fest';\nimport path from 'path';\n\nconst DEFAULT_FILENAME = 'tsconfig.json';\n\ninterface IsNodeModuleRequireOptions {\n  /**\n   * Whether to simulate windows.\n   *\n   * @default undefined\n   */\n  windows?: boolean;\n}\n\ninterface ParseFilePath {\n  /**\n   * True when the file path provided is an absolute path.\n   */\n  isAbsolute: boolean;\n\n  /**\n   * True when the file path potentially refers to a node module package.\n   */\n  isPackage: boolean;\n}\n\n/**\n * Extends the default node file parser and determines whether the path provided\n * should be resolved from the node modules or directly from the provided path.\n */\nconst parseFilePath = (\n  file: string,\n  { windows }: IsNodeModuleRequireOptions = {},\n): path.ParsedPath & ParseFilePath => {\n  const isWindows = windows ?? process.platform === 'win32';\n  const parser = isWindows ? path.win32.parse : path.parse;\n  const parsedPath = parser(file);\n\n  return {\n    ...parsedPath,\n    isAbsolute: Boolean(parsedPath.root),\n    isPackage: !file.startsWith('.') && !parsedPath.root,\n  };\n};\n\n/**\n * The reason that the tsconfig exist flag is false.\n */\nexport const TsConfigErrorReason = {\n  /**\n   * The `tsconfig` file could not be found.\n   */\n  NotFound: 'not-found',\n\n  /**\n   * The file was found but the configuration was invalid.\n   */\n  InvalidConfig: 'invalid-config',\n} as const;\n\ninterface TsConfigFailure {\n  /**\n   * Whether or not the configuration could be loaded.\n   *\n   * - `false` when no tsconfig could be found.\n   */\n  exists: false;\n\n  /**\n   * The configuration object.\n   *\n   * - `undefined` when the tsconfig resolver failed and no configuration was\n   *   found.\n   */\n  config?: undefined;\n}\n\nexport interface TsConfigFailureNotFound extends TsConfigFailure {\n  /**\n   * The reason for failure.\n   *\n   * - `TsConfigErrorReason.NotFound` when the config failure is because the\n   *   filename has not been found.\n   */\n  reason: typeof TsConfigErrorReason.NotFound;\n\n  /**\n   * The absolute path to the `tsconfig.json` or given filename.\n   *\n   * - `undefined` when not found.\n   */\n  path?: undefined;\n}\n\nexport interface TsConfigFailureInvalidConfig extends TsConfigFailure {\n  /**\n   * - `TsConfigErrorReason.InvalidConfig` when the config failure is because of\n   *   an invalid config.\n   */\n  reason: typeof TsConfigErrorReason.InvalidConfig;\n\n  /**\n   * - `string` when config json is invalid.\n   */\n  path: string;\n}\n\nexport interface TsConfigResultSuccess {\n  /**\n   * - `true` when a valid tsconfig file has been found and successfully loaded.\n   */\n  exists: true;\n\n  /**\n   * - `string` when a valid tsconfig has been loaded.\n   */\n  path: string;\n\n  /**\n   * - `TsConfigJson` when the resolved tsconfig has been found and loaded.\n   */\n  config: TsConfigJson;\n\n  /**\n   * - `undefined` when no failure has occurred.\n   */\n  reason?: undefined;\n}\n\n/**\n * The result of loading the tsconfig. If the exists property is `true` then\n * there will be a path and config property available.\n */\nexport type TsConfigResult =\n  | TsConfigFailureNotFound\n  | TsConfigFailureInvalidConfig\n  | TsConfigResultSuccess;\n\nexport interface TsConfigLoaderParams {\n  getEnv: (key: string) => string | undefined;\n  cwd: string;\n  loadSync?(cwd: string, fileName?: string): TsConfigResult;\n}\n\nconst walkForTsConfig = (directory: string): string | undefined => {\n  const configPath = join(directory, './tsconfig.json');\n  if (existsSync(configPath)) {\n    return configPath;\n  }\n\n  const parentDirectory = join(directory, '../');\n\n  // If we reached the top\n  if (directory === parentDirectory) {\n    return undefined;\n  }\n\n  return walkForTsConfig(parentDirectory);\n};\n\n/**\n * Check that the passed string is a directory.\n */\nconst isDirectory = (directory: string) => {\n  try {\n    return lstatSync(directory).isDirectory();\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Check that the passed filePath is a valid file.\n */\nconst isFile = (filePath: string) => {\n  try {\n    return lstatSync(filePath).isFile();\n  } catch {\n    return false;\n  }\n};\n\nconst resolveConfigPath = (\n  cwd: string,\n  fileName: string = DEFAULT_FILENAME,\n): string | undefined => {\n  if (fileName !== DEFAULT_FILENAME) {\n    const resolvedFileName = resolve(cwd, fileName);\n    const absolutePath = isDirectory(resolvedFileName)\n      ? resolve(resolvedFileName, 'tsconfig.json')\n      : resolvedFileName;\n\n    return isFile(absolutePath) ? absolutePath : undefined;\n  }\n\n  if (statSync(cwd).isFile()) {\n    return resolve(cwd);\n  }\n\n  const configAbsolutePath = walkForTsConfig(cwd);\n  return configAbsolutePath ? resolve(configAbsolutePath) : undefined;\n};\n\n/**\n * Loads the `jsonString` and returns it as a TsConfigJson object.\n */\nconst parseTsConfigJson = (jsonString: string): TsConfigJson | undefined => {\n  try {\n    const json = JSON5.parse(jsonString);\n    return json && typeof json === 'object' ? json : undefined;\n  } catch {\n    return undefined;\n  }\n};\n\n/**\n * Loads a tsconfig file while also resolving the extends path.\n */\nconst loadTsConfig = (configFilePath: string): TsConfigJson | undefined => {\n  if (!existsSync(configFilePath)) return undefined;\n\n  const configString = readFileSync(configFilePath, 'utf8');\n  const jsonString = StripBom(configString);\n  const config = parseTsConfigJson(jsonString);\n  let extendedConfig = config?.extends;\n\n  if (!config || !extendedConfig) return config;\n\n  let base: TsConfigJson;\n\n  if (parseFilePath(extendedConfig).isPackage) {\n    const newConfigPath = require.resolve(extendedConfig);\n\n    if (isDirectory(newConfigPath)) {\n      extendedConfig = join(newConfigPath, 'tsconfig.json');\n    } else if (isFile(newConfigPath)) {\n      extendedConfig = newConfigPath;\n    } else if (isFile(`${newConfigPath}.json`)) {\n      extendedConfig = `${newConfigPath}.json`;\n    }\n\n    base = loadTsConfig(extendedConfig) ?? {};\n  } else {\n    if (!extendedConfig.endsWith('.json')) {\n      extendedConfig += '.json';\n    }\n\n    const currentDir = dirname(configFilePath);\n    base = loadTsConfig(join(currentDir, extendedConfig)) ?? {};\n  }\n\n  // baseUrl should be interpreted as relative to the base tsconfig, but we need\n  // to update it so it is relative to the original tsconfig being loaded\n  if (base?.compilerOptions?.baseUrl) {\n    const extendsDir = dirname(extendedConfig);\n    base.compilerOptions.baseUrl = join(\n      extendsDir,\n      base.compilerOptions.baseUrl,\n    );\n  }\n\n  return {\n    ...base,\n    ...config,\n    compilerOptions: {\n      ...base.compilerOptions,\n      ...config.compilerOptions,\n    },\n  };\n};\n\nexport interface TsConfigResolverOptions {\n  /**\n   * The absolute directory to start resolving from.\n   *\n   * @default `process.cwd()`\n   */\n  cwd?: string;\n\n  /**\n   * The fileName to use.\n   *\n   * @default 'tsconfig.json'\n   */\n  fileName?: string;\n\n  /**\n   * The caching strategy to use.\n   *\n   * @default 'never'\n   *\n   * @remarks\n   *\n   * Sometimes you'll want to run this module several times during runtime but\n   * it can be slow and expensive walk up the file tree for the tsconfig value\n   * every time.\n   *\n   * To help prevent unnecessary lookups there are custom caching strategies\n   * available. See {@link CacheStrategy}.\n   */\n  cacheStrategy?: CacheStrategyType;\n}\n\nexport const CacheStrategy = {\n  /**\n   * Caching never happens and the returned value is always recalculated.\n   */\n  Never: 'never',\n\n  /**\n   * The first time the `tsconfigResolver` method is run it will save a cached\n   * value (by `fileName`) which will be returned every time after that. This\n   * value will always be the same.\n   */\n  Always: 'always',\n\n  /**\n   * The cache will be used when the same directory (and fileName) is being\n   * searched.\n   */\n  Directory: 'directory',\n} as const;\n\n/**\n * The available cache strategies as a union of strings.\n */\nexport type CacheStrategyType = typeof CacheStrategy[keyof typeof CacheStrategy];\n\nconst cacheObject = {\n  [CacheStrategy.Always]: new Map<string, TsConfigResult>(),\n  [CacheStrategy.Directory]: new Map<string, TsConfigResult>(),\n};\n\n/**\n * Based on the options passed in, retrieve the value from the cache or return\n * undefined if the value still needs to be calculated.\n */\nconst getCache = ({\n  cacheStrategy,\n  cwd,\n  fileName,\n}: Required<TsConfigResolverOptions>): TsConfigResult | undefined => {\n  if (cacheStrategy === CacheStrategy.Always) {\n    return cacheObject[CacheStrategy.Always].get(fileName);\n  }\n\n  if (cacheStrategy === CacheStrategy.Directory) {\n    return cacheObject[CacheStrategy.Always].get(join(cwd, fileName));\n  }\n\n  return undefined;\n};\n\n/**\n * Updates the cache with the provided result.\n */\nconst updateCache = (\n  { cacheStrategy, cwd, fileName }: Required<TsConfigResolverOptions>,\n  result: TsConfigResult,\n): void => {\n  if (cacheStrategy === CacheStrategy.Always) {\n    cacheObject[CacheStrategy.Always].set(fileName, result);\n  } else if (cacheStrategy === CacheStrategy.Directory) {\n    cacheObject[CacheStrategy.Always].set(join(cwd, fileName), result);\n  }\n};\n\n/**\n * Get the nearest tsconfig by walking up the directory.\n */\nconst getTsConfigResult = ({\n  cwd,\n  fileName,\n}: Required<\n  Except<TsConfigResolverOptions, 'cacheStrategy'>\n>): TsConfigResult => {\n  const configPath = resolveConfigPath(cwd, fileName);\n\n  if (!configPath) {\n    return {\n      exists: false,\n      reason: TsConfigErrorReason.NotFound,\n    };\n  }\n\n  const config = loadTsConfig(configPath);\n\n  if (!config) {\n    return {\n      exists: false,\n      reason: TsConfigErrorReason.InvalidConfig,\n      path: configPath,\n    };\n  }\n\n  return {\n    exists: true,\n    path: configPath,\n    config,\n  };\n};\n\n/**\n * Resolve the `tsconfig` file synchronously. Walks up the file tree until it\n * finds a file that matches the fileName.\n *\n * @param options - `TsConfigResolverOptions`.\n *\n * @returns an object containing whether a configuration was found and is valid.\n *\n * @remarks\n *\n * If a none default caching strategy is provided the returned result might be\n * from the cache instead.\n */\nexport function tsconfigResolver({\n  cwd = process.cwd(),\n  cacheStrategy = CacheStrategy.Never,\n  fileName = DEFAULT_FILENAME,\n}: TsConfigResolverOptions = {}): TsConfigResult {\n  const cache = getCache({ cwd, cacheStrategy, fileName });\n\n  if (cache) {\n    return cache;\n  }\n\n  const result = getTsConfigResult({ cwd, fileName });\n  updateCache({ cwd, cacheStrategy, fileName }, result);\n\n  return result;\n}\n\n/**\n * Clears the cache.\n */\nexport const clearCache = () => {\n  for (const map of Object.values(cacheObject)) {\n    map.clear();\n  }\n};\n"],"names":["TsConfigErrorReason","NotFound","InvalidConfig","isDirectory","directory","lstatSync","isFile","filePath","CacheStrategy","Never","Always","Directory","cacheObject","Map","Object","values","clear","cwd","process","cacheStrategy","fileName","cache","get","join","getCache","result","configPath","resolvedFileName","resolve","absolutePath","undefined","statSync","configAbsolutePath","walkForTsConfig","existsSync","parentDirectory","resolveConfigPath","exists","reason","config","loadTsConfig","configFilePath","base","file","windows","parsedPath","configString","readFileSync","jsonString","json","JSON5","parse","parseTsConfigJson","StripBom","extendedConfig","platform","path","win32","isAbsolute","Boolean","root","isPackage","startsWith","newConfigPath","require","endsWith","currentDir","dirname","_base","compilerOptions","_base$compilerOptions","baseUrl","extendsDir","getTsConfigResult","set","updateCache"],"mappings":"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"}